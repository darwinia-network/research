\begin{abstract}
To verify transactions, cryptocurrencies such as Bitcoin and Ethereum require nodes to verify that the blockchain is valid. This requirement means downloading and verifying all blocks, which takes hours and requires gigabytes of bandwidth and storage space. Therefore, clients with limited resources cannot independently verify transactions without trusting the full node. Bitcoin and Ethereum provide lightweight clients called simplified payment verification (SPV) clients that can verify the chain by downloading only the block header.  Unfortunately, the storage and bandwidth requirements of SPV clients still grow linearly with chain length. Recently, NIPoPoW and FlyClient have proposed a type of solution called super-light client. It is expected that light clients only need to download and store the logarithmic number of block headers, but this type of solution cannot be directly used for light clients on the chain, that is, cross-chain Relay. FlyClient requires making a certain degree of a hard fork to the corresponding chain and supports the Merkle Mountain Range (MMR) commitment before it can be used for relay on the chain, they all have a certain degree of poor generality, Non-Interactive Proof of Work (NIPoPoW) is only applicable to chains with fixed block difficulty, and FlyClient needs to modify the best probability block sampling protocol and variable-difficulty verification model.

We introduce Darwinia ChainRelay, which is a novel cross-chain verification relay, using technologies such as Merkle mountain range (MMR) commitment, optimistic verification game, super-light client framework, relay incentive model, etc. Darwinia ChainRelay is able to achieve sub-linear performance by only submitting logarithmic numbers of data including the block header and its derived data. Darwinia ChainRelay overcomes the limitations of FlyClient. The protocols do not need to fork the target chain to use MMR. It has strong generality and can be applied not only to the POW chain but also to other consensus algorithm chains such as POS. Also, by only storing a single block header between two verification executions, we can implement the protocol using the design of on-demand verification, that is, before each verification, we only need to submit one block header and make sure it is confirmed and finalized.

  \end{abstract}
